/**
 * @preserve FamilySearch JavaScript SDK
 * (c) 2013, Dallan Quass & Dovy Paukstys
 * License: MIT
*/

/**
 * @ngdoc overview
 * @name index
 * @description
 *
 * ##Getting started
 *
 * To use the SDK, you need to
 *
 * 1. init the SDK; e.g.,
 *
 * <pre>
 * FamilySearch.init({
 *   app_key: 'YOUR_ACCESS_KEY_GOES_HERE',
 *   environment: 'sandbox',
 *   // auth_callback is the URI you registered with FamilySearch;
 *   // the page does not need to exist but it must have the same host and port
 *   // as the server running your script
 *   auth_callback: 'REDIRECT_GOES_HERE',
 *   http_function: jQuery.ajax,
 *   deferred_function: jQuery.Deferred
 * });
 * </pre>
 *
 * 2. get an access token; e.g.,
 *
 * <pre>
 * FamilySearch.getAccessToken().then(function(response) {
 *    // now you have an access token
 * });
 * </pre>
 *
 * 3. make API calls; e.g.,
 *
 * <pre>
 * FamilySearch.getCurrentUser().then(function(response) {
 *    // now you have the response
 * });
 * </pre>
 *
 * ##Promises
 *
 * Most functions return promises.
 * The promises are generated by the `deferred_function` you passed into the `init` call.
 * If the promise is fulfilled, it will return a single parameter containing the response data.
 * If the response is rejected, it will return whatever the `http_function` passed into the `init` call returns.
 *
 * The following functions are also available
 *
 * - `getResponseHeader(header)`
 * - `getAllResponseHeaders()`
 * - `getStatusCode()`
 *
 * ###Examples
 *
 * ####jQuery
 *
 * Requires jQuery 1.8 or later.
 *
 * If you pass `jQuery.ajax` and `jQuery.Deferred` into the `FamilySearch.init` call, the returned promises
 * will have the the methods described at http://api.jquery.com/Types/#Promise ; for example
 *
 * - `then(function(data) {}, function(jqXHR, textStatus, errorThrown) {})`
 * - `done(function(data) {})`
 * - `fail(function(jqXHR, textStatus, errorThrown) {})`
 *
 * ####AngularJS -- not yet implemented
 *
 * If you pass `$http` and `$q.defer` into the `FamilySearch.init` call, the returned promises
 * will have the methods described at http://docs.angularjs.org/api/ng.$q#description_the-promise-api ; for example
 *
 * - `then(function(data) {}, function({data: data, status: status, headers: headers, config: config}) {})`
 * - `catch(function(data, status, headers, config) {})`
 *
 * ####Node.js -- not yet implemented
 *
 * ##Plumbing
 *
 * The functions in the "plumbing" module are low-level functions that you would not normally call.
 * The higher-level functions that you normally call are built on top of the plumbing functions.
 * The plumbing functions are exposed in case you want to do something not anticipated by the higher-level functions.
 * The plumbing functions here serve the same purpose as the
 * [plumbing functions in git](https://www.kernel.org/pub/software/scm/git/docs/#_low_level_commands_plumbing).
 *
 * Note that promises returned by plumbing functions return whatever the `http_function` passed into the
 * `init` call returns.
 *
 */

;(function() {
  'use strict';

  var appKey,
    environment,
    httpWrapper,
    deferredWrapper,
    authCallbackUri,
    autoSignin,
    accessToken = null,
    saveAccessToken = false,
    logging,
    server = {
      'sandbox'   : 'https://sandbox.familysearch.org',
      'staging'   : 'https://stage.familysearch.org',
      'production': 'https://familysearch.org'
    },
    oauthServer = {
      'sandbox'   : 'https://sandbox.familysearch.org/cis-web/oauth2/v3',
      'staging'   : 'https://identbeta.familysearch.org/cis-web/oauth2/v3',
      'production': 'https://ident.familysearch.org/cis-web/oauth2/v3'
    },
    accessTokenCookie = 'FS_ACCESS_TOKEN',
    authCodePollDelay = 50,
    defaultThrottleRetryAfter = 500,
    maxHttpRequestRetries = 5,
    totalProcessingTime = 0;


  //==================================================================================================================
  // INITIALIZATION
  //==================================================================================================================

  /**
   * @ngdoc overview
   * @name init
   * @description
   * Call the init function once to initialize the FamilySearch object before calling any other functions.
   */

  /**
   * @ngdoc function
   * @name init.functions:init
   * @function
   *
   * @description
   * Initialize the FamilySearch object
   *
   * **Options**
   *
   * - `app_key` - the developer key you received from FamilySearch
   * - `environment` - sandbox, staging, or production
   * - `http_function` - a function for issuing http requests: jQuery.ajax, and eventually angular's $http, or node.js's ...
   * - `deferred_function` - a function for creating deferred's: jQuery.Deferred, and eventually angular's $q or Q
   * - `auth_callback` - the OAuth2 redirect uri you registered with FamilySearch.  Does not need to exist, but must have the same host and port as the server running your script
   * - `auto_signin` - set to true if you want the user to be prompted to sign in when a call returns 401 unauthorized (must be false for node.js, and may require the user to enable popups in their browser)
   * - `access_token` - pass this in if you already have an access token
   * - `save_access_token` - set to true if you want the access token to be saved and re-read in future init calls (uses a session cookie)
   * - `logging` - not currently used
   *
   * @param {Object} opts options
   */
  function init(opts) {
    opts = opts || {};

    if(!opts['app_key']) {
      throw 'app_key must be set';
    }
    appKey = opts['app_key'];

    if(!opts['environment']) {
      throw 'environment must be set';
    }
    environment = opts['environment'];

    if(!opts['http_function']) {
      throw 'http must be set; e.g., jQuery.ajax';
    }
    httpWrapper = jqueryHttpWrapper(opts['http_function']);

    if(!opts['deferred_function']) {
      throw 'deferred_function must be set; e.g., jQuery.Deferred';
    }
    deferredWrapper = jqueryDeferredWrapper(opts['deferred_function']);

    if(opts['auth_callback']) {
      authCallbackUri = opts['auth_callback'];
    }

    if(opts['auto_signin']) {
      autoSignin = opts['auto_signin'];
    }

    if (opts['save_access_token']) {
      saveAccessToken = true;
      accessToken = readCookie(accessTokenCookie);
    }

    if(opts['access_token']) {
      accessToken = opts['access_token'];
    }

    logging = opts['logging'];
  }

  //==================================================================================================================
  // AUTHENTICATION
  //==================================================================================================================

  /**
   * @ngdoc overview
   * @name authentication
   * @description
   * These are the authentication functions. `getAccessToken` is the main function.
   * If you do not pass in an authorization code to `getAccessToken`, it will call the `getAuthCode` function to get one.
   *
   * {@link https://familysearch.org/developers/docs/api/resources#authentication FamilySearch API docs}
   */

  /**
   * @ngdoc function
   * @name authentication.functions:getAuthCode
   * @function
   *
   * @description
   * Open a popup window to allow the user to authenticate and authorize this application.
   * You do not have to call this function. If you call `getAccessToken` without passing in an authorization code,
   * that function will call this function to get one.
   *
   * @link https://familysearch.org/developers/docs/api/authentication/Authorization_resource FamilySearch API docs}
   *
   * @return {Object} a promise of the (string) auth code
   */
  function getAuthCode() {
    var popup = openPopup(getAbsoluteUrl(oauthServer[environment], 'authorization'), {
      'response_type' : 'code',
      'client_id'     : appKey,
      'redirect_uri'  : authCallbackUri
    });
    return pollForAuthCode(popup);
  }

  /**
   * @ngdoc function
   * @name authentication.functions:getAccessToken
   * @function
   *
   * @description
   * Get the access token for the user.
   * Call this function before making any requests that require authentication.
   *
   * You don't need to store the access token returned by this function; you just need to ensure that the promise
   * returned by this function resolves before making calls that require authentication.
   *
   * {@link https://familysearch.org/developers/docs/api/authentication/Access_Token_resource FamilySearch API docs}
   *
   * {@link http://jsfiddle.net/DallanQ/MpUg7/ editable example}
   *
   * @param {String=} authCode auth code from getAuthCode; if not passed in, this function will call getAuthCode
   * @return {Object} a promise of the (string) access token.
   */
  function getAccessToken(authCode) {
    var accessTokenDeferred = deferredWrapper();
    if (accessToken) {
      nextTick(function() {
        accessTokenDeferred.resolve(accessToken);
      });
    }
    else {
      // get auth code if not passed in
      var authCodePromise;
      if (authCode) {
        authCodePromise = refPromise(authCode);
      }
      else {
        authCodePromise = getAuthCode();
      }
      authCodePromise.then(
        function(authCode) {
          // get the access token given the auth code
          var promise = post(getAbsoluteUrl(oauthServer[environment], 'token'), {
            'grant_type' : 'authorization_code',
            'code'       : authCode,
            'client_id'  : appKey
          });
          promise.then(
            function(data) {
              accessToken = data['access_token'];
              if (accessToken) {
                accessTokenDeferred.resolve(accessToken);
                if (saveAccessToken) {
                  createCookie(accessTokenCookie, accessToken, 0);
                }
              }
              else {
                accessTokenDeferred.reject(data['error']);
              }
            },
            function() {
              accessTokenDeferred.reject.apply(accessTokenDeferred, arguments);
            });
        },
        function() {
          accessTokenDeferred.reject.apply(accessTokenDeferred, arguments);
        });
    }
    return accessTokenDeferred.promise;
  }

  /**
   * @ngdoc function
   * @name authentication.functions:hasAccessToken
   * @function
   *
   * @description
   * Return whether the access token exists.
   * The access token may exist but be expired.
   * An access token is discovered to be expired and is erased if an API call returns a 401 unauthorized status
   *
   * @return {boolean} true if the access token exists
   */
  function hasAccessToken() {
    return !!accessToken;
  }

  /**
   * @ngdoc function
   * @name authentication.functions:invalidateAccessToken
   * @function
   *
   * @description
   * Invalidate the current access token
   *
   * @return {Object} promise that is resolved once the access token has been invalidated
   */
  function invalidateAccessToken() {
    eraseAccessToken();
    return del(getAbsoluteUrl(oauthServer[environment], 'token'));
  }

  //==================================================================================================================
  // USER
  //==================================================================================================================

  /**
   * @ngdoc overview
   * @name user
   * @description
   * Functions related to users
   *
   * {@link https://familysearch.org/developers/docs/api/resources#user FamilySearch API Docs}
   */

  /**
   * @ngdoc function
   * @name user.functions:getCurrentUser
   * @function
   *
   * @description
   * Get the current user with the following convenience functions
   *
   * - `getContactName()`
   * - `getFullName()`
   * - `getEmail()`
   * - `getId()`
   * - `getTreeUserId()`
   *
   * {@link https://familysearch.org/developers/docs/api/users/Current_User_resource FamilySearch API Docs}
   *
   * {@link http://jsfiddle.net/DallanQ/3NJFM/ editable example}
   *
   * @param {Object=} opts options to pass to the http function specified during init
   * @return {Object} a promise for the current user
   */
  function getCurrentUser(opts) {
    return get('/platform/users/current', {}, {}, opts, objectExtender(currentUserConvenienceFunctions));
  }
  var currentUserConvenienceFunctions = {
    getContactName: function() { return this.users[0].contactName; },
    getFullName:    function() { return this.users[0].fullName; },
    getEmail:       function() { return this.users[0].email; },
    getId:          function() { return this.users[0].id; },
    getTreeUserId:  function() { return this.users[0].treeUserId; }
  };

  /**
   * @ngdoc function
   * @name user.functions:getCurrentUserPerson
   * @function
   *
   * @description
   * Get the id of the current user person in the tree
   *
   * {@link https://familysearch.org/developers/docs/api/tree/Current_User_Person_resource FamilySearch API Docs}
   *
   * {@link http://jsfiddle.net/DallanQ/c4puF/ editable example}
   *
   * @param {Object=} opts options to pass to the http function specified during init
   * @return {Object} promise for the (string) id of the current user person
   */
  function getCurrentUserPerson(opts) {
    var promise = get('/platform/tree/current-person', {}, {}, opts);
    var d = deferredWrapper();
    var returnedPromise = extendHttpPromise(d.promise, promise);
    promise.then(
      function() {
        handleCurrentUserPersonResponse(d, promise);
      },
      function() {
        // in Chrome, the current person response is expected to fail because it involves a redirect and chrome doesn't
        // re-send the Accept header on a CORS redirect, so the response comes back as XML and jQuery can't parse it.
        // That's ok, because we'll pick up the ID from the Content-Location header
        handleCurrentUserPersonResponse(d, promise);
      });

    return returnedPromise;
  }

  // common code for current user person promise fulfillment and failure
  function handleCurrentUserPersonResponse(d, promise) {
    var id = null;
    // this is the expected result for Node.js because it doesn't follow redirects
    var location = promise.getResponseHeader('Location');
    if (!location) {
      // this is the expected result for browsers because they follow redirects
      // NOTE: Chrome doesn't re-send the accept header on CORS redirect requests, so the request fails because we can't
      // parse the returned XML into JSON. We still get a Content-Location header though.
      location = promise.getResponseHeader('Content-Location');
    }

    if (location) {
      var matchResult = location.match(/\/persons\/([^?]*)/);
      if (matchResult) {
        id = matchResult[1];
      }
    }

    if (id) {
      d.resolve(id);
    }
    else {
      d.reject('not found');
    }
  }

  //==================================================================================================================
  // PERSON
  //==================================================================================================================

  /**
   * @ngdoc overview
   * @name person
   * @description
   * Functions related to persons
   *
   * {@link https://familysearch.org/developers/docs/api/resources#person FamilySearch API Docs}
   */

  /**
   * @ngdoc function
   * @name person.functions:getPerson
   * @function
   *
   * @description
   * Get the specified person
   * The response includes the following convenience function
   *
   * - `getPerson()` - gets the person object from the response, which has been extended with the *person convenience functions* listed below
   *
   * ###Person Convenience Functions
   *
   * - `getId()`
   * - `getBirthDate()`
   * - `getBirthPlace()`
   * - `getDeathDate()`
   * - `getDeathPlace()`
   * - `getGender()`
   * - `getLifeSpan()`
   * - `getName()`
   * - `isLiving()`
   * - `getGivenName()`
   * - `getSurname()`
   * - `getDisplayAttrs()` - returns an object with birthDate, birthPlace, deathDate, deathPlace, gender, lifespan, and name
   *
   * ###Components
   *
   * Additional information can be obtained by passing in components. If you don't pass in any components, `base` is assumed.
   * Components extend the returned response and add additional convenience functions as described below
   *
   * ####`base`
   *
   * - adds the *person convenience functions* described above; if you don't include base, only the `getId()` function is available
   *
   * ####`change-summary`
   *
   * - `getChanges()` - an array of summarized changes
   *
   * ####`child-relationships`
   *
   * - not yet implemented
   *
   * ####`discussion-references`
   *
   * - not yet implemented
   *
   * ####`matches`
   *
   * - not yet implemented
   *
   * ####`memory-references`
   *
   * - not yet implemented
   *
   * ####`not-a-match`
   *
   * - not yet implemented
   *
   * ####`notes`
   *
   * - `getPerson()`.`getNotes()` - an array of notes
   *
   * ####`parent-relationships`
   *
   * - not yet implemented
   *
   * ####`source-references`
   *
   * - not yet implemented
   *
   * ####`spouse-relationships`
   *
   * - not yet implemented
   *
   * {@link https://familysearch.org/developers/docs/api/tree/Person_resource FamilySearch API Docs}
   *
   * {@link http://jsfiddle.net/DallanQ/cST4L/ editable example}
   *
   * @param {String} id of the person to read
   * @param {Array=} components zero or more of `base`, `change-summary`, `changes`, `child-relationships`, `discussion-references`,
   * `matches`, `memory-references`, `not-a-match`, `notes`, `parent-relationsihps`, `source-references`, `spouse-relationships`
   * @param {Object=} opts options to pass to the http function specified during init
   * @return {Object} promise for the response
   */
  function getPerson(id, components, opts) {
    if (!isArray(components) || components.length === 0) {
      components = ['base'];
    }
    var promises = {};
    forEach(components, function(component) {
      var suffix = component === 'base' ? '' : '/'+component;
      var headers = component === 'change-summary' ? {'Accept': 'application/x-gedcomx-atom+json'} : {};
      promises[component] = get('/platform/tree/persons/'+encodeURI(id)+suffix, {}, headers, opts,
        compose(
          objectExtender({getPerson: function() { return this.persons[0]; }}),
          personResponseMappers[component]
        )
      );
    });
    var result = {};
    return promiseAll(promises).then(function(responses) {
      forEach(components, function(component) {
        result = deepExtend(result, responses[component]);
      });
      return result;
    });
  }

  function personExtensionPointGetter(response) {
    return response.persons;
  }

  var personConvenienceFunctions = {
    getId:         function() { return this.id; },
    getBirthDate:  function() { return this.display.birthDate; },
    getBirthPlace: function() { return this.display.birthPlace; },
    getDeathDate:  function() { return this.display.deathDate; },
    getDeathPlace: function() { return this.display.deathPlace; },
    getGender:     function() { return this.display.gender; },
    getLifeSpan:   function() { return this.display.lifespan; },
    getName:       function() { return this.display.name; },
    isLiving:      function() { return this.living; },
    getGivenName:  function() { return findOrEmpty(firstOrEmpty(findOrEmpty(this.names, {preferred: true}).nameForms).parts,
      {type: 'http://gedcomx.org/Given'}).value; },
    getSurname:    function() { return findOrEmpty(firstOrEmpty(findOrEmpty(this.names, {preferred: true}).nameForms).parts,
      {type: 'http://gedcomx.org/Surname'}).value; },
    getDisplayAttrs: function() { return this.display; }
  };

  var personExtender = objectExtender(personConvenienceFunctions, personExtensionPointGetter);

  var personResponseMappers = {
    base: personExtender,
    'change-summary': objectExtender({getChanges: function() { return this.entries; }}),
    notes: objectExtender({getNotes: function() { return this.notes; }}, personExtensionPointGetter)
  };

  /**
   * @ngdoc function
   * @name person.functions:getMultiPerson
   * @function
   *
   * @description
   * Get multiple people at once by requesting them in parallel
   *
   * {@link https://familysearch.org/developers/docs/api/tree/Person_resource FamilySearch API Docs}
   *
   * {@link http://jsfiddle.net/DallanQ/TF6Lg/ editable example}
   *
   * @param {Array} ids of the people to read
   * @param {Array=} components to pass to getPerson
   * @param {Object=} opts options to pass to the http function specified during init
   * @return {Object} promise that is fulfilled when all of the people have been read, returning a map of person id to response
   */
  function getMultiPerson(ids, components, opts) {
    var promises = {};
    forEach(ids, function(id) {
      promises[id] = getPerson(id, components, opts);
    });
    return promiseAll(promises);
  }

  /**
   * @ngdoc function
   * @name person.functions:getPersonWithRelationships
   * @function
   *
   * @description
   * Get a person and their children, spouses, and parents with the following convenience functions
   *
   * - `getPrimaryId()` - id of the person requested
   * - `getFatherIds()` - array of ids
   * - `getMotherIds()` - array of ids
   * - `getParentsIds()` - array of [fatherId, motherId]
   * - `getSpouseIds()` - array of ids
   * - `getChildIds(spouseId)` - array of ids; if spouseId is specified, returns only ids of children with spouse as the other parent
   *
   * The following functions return person objects decorated with *person convenience functions* {@link person.functions:getPerson as described in getPerson}
   *
   * - `getPrimaryPerson()`
   * - `getPerson(id)` - works only for the primary person unless the components parameter is set to `['persons']`
   *
   *   In addition, the following functions are available if the components parameter is set to `['persons']`
   * - `getFathers()` - array of father persons
   * - `getMothers()` - array of mother persons
   * - `getParents()` - array of [father person, mother person]
   * - `getSpouses()` - array of spouse persons
   * - `getChildren(spouseId)` - array of child persons; if spouseId is specified returns only children with spouse as the other parent
   *
   * {@link https://familysearch.org/developers/docs/api/tree/Person_With_Relationships_resource FamilySearch API Docs}
   *
   * {@link http://jsfiddle.net/DallanQ/5Npsh/ editable example}
   *
   * @param {String} id person to read
   * @param {Array=} components set to ['persons'] if you want to include full person objects for each relative
   * @param {Object=} opts options to pass to the http function specified during init
   * @return {Object} promise for the person with relationships
   */
  function getPersonWithRelationships(id, components, opts) {
    var params = { person: id };
    if (isArray(components) && components.indexOf('persons') >= 0) {
      params['persons'] = 'true';
    }
    return get('/platform/tree/persons-with-relationships', params, {}, opts,
      compose(objectExtender(personWithRelationshipsConvenienceFunctions), personExtender));
  }

  // TODO how identify preferred parents?
  var personWithRelationshipsConvenienceFunctions = {
    getPerson:     function(id) { return findOrEmpty(this.persons, {id: id}); },
    getPrimaryId:  function() { return findOrEmpty(this.persons, function(p) { return p.display.ascendancyNumber === '1';}).id; },
    getPrimaryPerson: function() { return this.getPerson(this.getPrimaryId()); },
    getFatherIds:  function() {
      var primaryId = this.getPrimaryId();
      return uniq(map(filter(this.childAndParentsRelationships,
                             function(r) { return r.child.resourceId === primaryId && r.father; }),
                      function(r) { return r.father.resourceId; }));
    },
    getFathers:    function() { return map(this.getFatherIds(), this.getPerson, this); },
    getMotherIds:  function() {
      var primaryId = this.getPrimaryId();
      return uniq(map(filter(this.childAndParentsRelationships,
                             function(r) { return r.child.resourceId === primaryId && r.mother; }),
                      function(r) { return r.mother.resourceId; }));
    },
    getMothers:    function() { return map(this.getMotherIds(), this.getPerson, this); },
    getParentsIds: function() {
      var primaryId = this.getPrimaryId();
      return map(filter(this.childAndParentsRelationships,
                        function(r) { return r.child.resourceId === primaryId && (r.father || r.mother); }),
                 function(r) { return [ r.father ? r.father.resourceId : '', r.mother ? r.mother.resourceId : '']; });
    },
    getParents:    function() {
      return map(this.getParentsIds(), function(parentIds) {
        return [this.getPerson(parentIds[0]), this.getPerson(parentIds[1])];
      }, this);
    },
    getSpouseIds:  function() {
      var primaryId = this.getPrimaryId();
      return uniq(map(filter(this.relationships, function(r) {
                               return r.type === 'http://gedcomx.org/Couple' &&
                               (r.person1.resourceId === primaryId || r.person2.resourceId === primaryId);
                             }),
                      function(r) { return r.person1.resourceId === primaryId ? r.person2.resourceId : r.person1.resourceId; }));
    },
    getSpouses:    function() { return map(this.getSpouseIds(), this.getPerson, this); },
    getChildIds:   function(spouseId) {
      var primaryId = this.getPrimaryId();
      return uniq(map(filter(this.childAndParentsRelationships, function(r) {
                               return childParentRelationshipHasParent(r, primaryId) &&
                                      (!spouseId || childParentRelationshipHasParent(r, spouseId));
                             }),
                      function(r) { return r.child.resourceId; }));
    },
    getChildren:   function(spouseId) { return map(this.getChildIds(spouseId), this.getPerson, this); }
  };

  function childParentRelationshipHasParent(r, parentId) {
    return (r.father && r.father.resourceId === parentId) || (r.mother && r.mother.resourceId === parentId);
  }

  //==================================================================================================================
  // PEDIGREE
  //==================================================================================================================

  /**
   * @ngdoc overview
   * @name pedigree
   * @description
   * Get someone's ancestry or descendancy
   *
   * {@link https://familysearch.org/developers/docs/api/resources#pedigree FamilySearch API Docs}
   */

  /**
   * @ngdoc function
   * @name pedigree.functions:getAncestry
   * @function
   *
   * @description
   * Get the ancestors of a specified person and optionally a specified spouse with the following convenience functions
   *
   * - `exists(ascendancyNumber)` - return true if a person with ascendancy number exists
   *
   * The following functions return person objects decorated with *person convenience functions* {@link person.functions:getPerson as described in getPerson}
   * as well as a `getAscendancyNumber()` function that returns the person's ascendancy number
   *
   * - `getPersons()` - returns an array of all persons
   * - `getPerson(ascendancyNumber)`
   *
   * **NOTE:** the `getBirthDate()`, `getBirthPlace()`, `getDeathDate()`, and `getDeathPlace()` person convenience functions
   * are available only if the `components` parameter is set to `['personDetails']`
   *
   * {@link https://familysearch.org/developers/docs/api/tree/Ancestry_resource FamilySearch API Docs}
   *
   * {@link http://jsfiddle.net/DallanQ/gt726/ editable example}
   *
   * @param {String} id of the person
   * @param {Number=} generations number of generations to retrieve (max 8)
   * @param {String=} spouseId spouse id
   * @param {Array=} components set to `['personDetails']` if you want to include full person objects for each ancestor
   * @param {Object=} opts options to pass to the http function specified during init
   * @return {Object} promise for the ancestry
   */
  function getAncestry(id, generations, spouseId, components, opts) {
    var args = getOptionalArgs(Array.prototype.slice.call(arguments, 1), [isNumber, isString, isArray, isObject]);
    generations = args[0]; spouseId = args[1]; components = args[2]; opts = args[3];
    var personDetails = isArray(components) && components.indexOf('personDetails') >= 0 ? true : '';

    return get('/platform/tree/ancestry', removeEmptyProperties({
      'person': id,
      'generations': generations,
      'spouse': spouseId,
      'personDetails': personDetails}),
      {}, opts,
      compose(
        objectExtender(pedigreeConvenienceFunctionGenerator('ascendancyNumber')),
        personExtender,
        objectExtender({getAscendancyNumber: function() { return this.display.ascendancyNumber; }}, personExtensionPointGetter)
      ));
  }

  function pedigreeConvenienceFunctionGenerator(numberLabel) {
    return {
      getPersons:    function()    { return this.persons; },
      exists:        function(num) { return !!findOrEmpty(this.persons, matchPersonNum(numberLabel, num)).id; },
      getPerson:     function(num) { return findOrEmpty(this.persons, matchPersonNum(numberLabel, num)); }
    };
  }

  function matchPersonNum(numberLabel, num) {
    return function(p) {
      /*jshint eqeqeq:false */
      return p.display[numberLabel] == num; // == so users can pass in either numbers or strings for ascendancy numbers
    };
  }

  //noinspection JSUnusedLocalSymbols
  /**
   * @ngdoc function
   * @name pedigree.functions:getDescendancy
   * @function
   *
   * @description
   * Get the descendants of a specified person and optionally a specified spouse with the following convenience functions
   * (similar convenience functions as getAncestry)
   *
   * - `exists(descendancyNumber)` - return true if a person with descendancy number exists
   *
   * The following functions return person objects decorated with *person convenience functions* {@link person.functions:getPerson as described in getPerson}
   * as well as a `getDescendancyNumber()` function that returns the person's descendancy number
   *
   * - `getPersons()` - returns all persons
   * - `getPerson(descendancyNumber)`
   *
   * {@link https://familysearch.org/developers/docs/api/tree/Descendancy_resource FamilySearch API Docs}
   *
   * {@link http://jsfiddle.net/DallanQ/eBNGk/ editable example}
   *
   * @param {String} id of the person
   * @param {Number=} generations number of generations to retrieve (max 2)
   * @param {String=} spouseId spouse id
   * @param {Array=} components currently not used
   * @param {Object=} opts options to pass to the http function specified during init
   * @return {Object} promise for the descendancy
   */
  function getDescendancy(id, generations, spouseId, components, opts) {
    return get('/platform/tree/descendancy', removeEmptyProperties({
      'person': id,
      'generations': generations,
      'spouse': spouseId}),
      {}, opts,
      compose(
        objectExtender(pedigreeConvenienceFunctionGenerator('descendancyNumber')),
        personExtender,
        objectExtender({getDescendancyNumber: function() { return this.display.descendancyNumber; }}, personExtensionPointGetter)
      ));
  }

  //==================================================================================================================
  // PLUMBING
  //==================================================================================================================

  /**
   * @ngdoc overview
   * @name plumbing
   * @description
   * These are the low-level "plumbing" functions. You don't normally need to use these functions.
   */

  /**
   * @ngdoc function
   * @name plumbing.functions:getTotalProcessingTime
   * @function
   * @description
   * Return the total "processing time" spent in FamilySearch REST endpoints
   *
   * @return {Number} time in milliseconds
   */
  function getTotalProcessingTime() {
    return totalProcessingTime;
  }

  /**
   * @ngdoc function
   * @name plumbing.functions:setTotalProcessingTime
   * @function
   * @description
   * Set the "processing time" spent in FamilySearch REST endpoints.
   * You could use this to reset the processing time counter to zero if you wanted.
   *
   * @param {Number} time in milliseconds
   */
  function setTotalProcessingTime(time) {
    totalProcessingTime = time;
  }

  /**
   * @ngdoc function
   * @name plumbing.functions:get
   * @function
   *
   * @description
   * Low-level call to get a specific REST endpoint from FamilySearch
   *
   * @param {String} url may be relative; e.g., /platform/users/current
   * @param {Object=} params query parameters
   * @param {Object=} headers options headers
   * @param {Object=} opts options to pass to the http function specified during init
   * @param {Function=} responseMapper function to map response data to something else
   * @return {Object} a promise that behaves like promises returned by the http function specified during init
   */
  function get(url, params, headers, opts, responseMapper) {
    return http('GET', appendQueryParameters(url, params), extend({'Accept': 'application/x-gedcomx-v1+json'}, headers), {}, opts, responseMapper);
  }

  /**
   * @ngdoc function
   * @name plumbing.functions:post
   * @function
   *
   * @description
   * Low-level call to post to a specific REST endpoint from FamilySearch
   *
   * @param {String} url may be relative
   * @param {Object=} data post data
   * @param {Object=} headers options headers
   * @param {Object=} opts options to pass to the http function specified during init
   * @param {Function=} responseMapper function to map response data to something else
   * @return {Object} a promise that behaves like promises returned by the http function specified during init
   */
  function post(url, data, headers, opts, responseMapper) {
    return http('POST', url, extend({'Content-type': 'application/x-www-form-urlencoded'},headers), data, opts, responseMapper);
  }

  /**
   * @ngdoc function
   * @name plumbing.functions:put
   * @function
   *
   * @description
   * Low-level call to put to a specific REST endpoint from FamilySearch
   *
   * @param {String} url may be relative
   * @param {Object=} data post data
   * @param {Object=} headers options headers
   * @param {Object=} opts options to pass to the http function specified during init
   * @param {Function=} responseMapper function to map response data to something else
   * @return {Object} a promise that behaves like promises returned by the http function specified during init
   */
  function put(url, data, headers, opts, responseMapper) {
    return http('PUT', url, extend({'Content-type': 'application/x-www-form-urlencoded'},headers), data, opts, responseMapper);
  }

  /**
   * @ngdoc function
   * @name plumbing.functions:del
   * @function
   *
   * @description
   * Low-level call to delete to a specific REST endpoint from FamilySearch
   *
   * @param {String} url may be relative
   * @param {Object=} opts options to pass to the http function specified during init
   * @param {Object=} headers options headers
   * @param {Function=} responseMapper function to map response data to something else
   * @return {Object} a promise that behaves like promises returned by the http function specified during init
   */
  function del(url, headers, opts, responseMapper) {
    return http('DELETE', url, headers, {}, opts, responseMapper);
  }

  /**
   * @ngdoc function
   * @name plumbing.functions:http
   * @function
   *
   * @description
   * Low-level call to issue an http request to a specific REST endpoint from FamilySearch
   *
   * @param {String} method GET, POST, PUT, or DELETE
   * @param {String} url may be relative
   * @param {Object=} headers headers object
   * @param {Object=} data post data
   * @param {Object=} opts options to pass to the http function specified during init
   * @param {Function=} responseMapper function to map response data into the data to return
   * @param {Number=} retries number of times to retry
   * @return {Object} a promise that behaves like promises returned by the http function specified during init
   */
  function http(method, url, headers, data, opts, responseMapper, retries) {
    // prepend the server
    var absoluteUrl = getAbsoluteUrl(server[environment], url);

    // append the access token as a query parameter to avoid cors pre-flight
    // this is detrimental to browser caching across sessions, which seems less bad than cors pre-flight requests
    // TODO investigate this further
    if (accessToken) {
      absoluteUrl = appendQueryParameters(absoluteUrl, {'access_token': accessToken});
    }

    // default retries
    if (retries == null) { // also catches undefined
      retries = maxHttpRequestRetries;
    }

    // call the http wrapper
    var promise = httpWrapper(method, absoluteUrl, headers || {}, data || {}, opts || {});

    // process the response
    var d = deferredWrapper();
    var returnedPromise = extendHttpPromise(d.promise, promise);
    promise.then(
      function(data) {
        var processingTime = promise.getResponseHeader('X-PROCESSING-TIME');
        if (processingTime) {
          totalProcessingTime += parseInt(processingTime,10);
        }
        if (responseMapper) {
          data = responseMapper(data);
        }
        d.resolve(data);
      },
      function() {
        var statusCode = promise.getStatusCode();
        console.log('http failure', statusCode, retries, promise.getAllResponseHeaders());
        if (statusCode === 401) {
          eraseAccessToken();
        }
        if (retries > 0 && (statusCode === 429 || (statusCode === 401 && autoSignin))) {
          var retryAfter = 0;
          if (statusCode === 429) {
            var retryAfterHeader = promise.getResponseHeader('Retry-After');
            console.log('retryAfter',retryAfterHeader, promise.getAllResponseHeaders());
            if (retryAfterHeader) {
              retryAfter = parseInt(retryAfterHeader,10);
            }
            else {
              retryAfter = defaultThrottleRetryAfter;
            }
          }
          getAccessToken().then(
            function() { // promise will resolve right away if access code exists
              setTimeout(function() {
                promise = http(method, url, headers, data, opts, responseMapper, retries-1);
                extendHttpPromise(returnedPromise, promise);
                promise.then(
                  function(data) {
                    d.resolve(data);
                  },
                  function() {
                    d.reject.apply(d, arguments);
                  });
              }, retryAfter);
            });
        }
        else {
          d.reject.apply(d, arguments);
        }
      });
    return returnedPromise;
  }

  //==================================================================================================================
  // HELPER FUNCTIONS
  //==================================================================================================================

  // borrowed from underscore.js
  function isArray(value) {
    /*jshint eqeqeq:false */
    return Array.isArray ? Array.isArray(value) : Object.prototype.toString.call(value) == '[object Array]';
  }

  // borrowed from underscore.js
  function isNumber(value) {
    /*jshint eqeqeq:false */
    return Object.prototype.toString.call(value) == '[object Number]';
  }

  // borrowed from underscore.js
  function isString(value) {
    /*jshint eqeqeq:false */
    return Object.prototype.toString.call(value) == '[object String]';
  }

  // borrowed from underscore.js
  function isFunction(value) {
    /*jshint eqeqeq:false */
    return (typeof /./ !== 'function') ? (typeof value === 'function') : Object.prototype.toString.call(value) == '[object Function]';
  }

  // borrowed from underscore.js
  function isObject(obj) {
    return obj === Object(obj);
  }

  // borrowed from underscore.js
  function isUndefined(value) {
    return value === void 0;
  }

  // borrowed from underscore.js
  function forEach(obj, iterator, context) {
    if (obj == null) { // also catches undefined
      return;
    }
    if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === {}) {
          return;
        }
      }
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (iterator.call(context, obj[key], key, obj) === {}) {
            return;
          }
        }
      }
    }
  }

  // simplified version of underscore's filter
  function filter(arr, fn) {
    var result = [];
    forEach(arr, function(e) {
      if (fn(e)) {
        result.push(e);
      }
    });
    return result;
  }

  // simplified version of underscore's map
  function map(arr, fn, context) {
    var result = [];
    forEach(arr, function(value, index, list) {
      result.push(fn.call(context, value, index, list));
    });
    return result;
  }

  // return only unique elements of an array preserving order
  function uniq(arr) {
    var u = {}, result = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      var e = arr[i];
      if (!u.hasOwnProperty(e)) {
        result.push(e);
        u[e] = 1;
      }
    }
    return result;
  }

  // simplified version of underscore's find
  // also, returns an empty object if the no matching elements found
  function findOrEmpty(arr, objOrFn) {
    var result = {};
    var isFn = isFunction(objOrFn);
    if (arr) {
      for (var i = 0, len = arr.length; i < len; i++) {
        var elm = arr[i];
        var matches;
        if (isFn) {
          matches = objOrFn.call(null, elm);
        }
        else {
          matches = true;
          for (var key in objOrFn) {
            if (objOrFn.hasOwnProperty(key) && elm[key] !== objOrFn[key]) {
              matches = false;
              break;
            }
          }
        }
        if (matches) {
          result = elm;
          break;
        }
      }
    }
    return result;
  }

  // returns the first element of the array or an empty object
  function firstOrEmpty(arr) {
    return (arr && arr.length > 0 ? arr[0] : {});
  }

  function extend(dest) {
    if (dest) {
      forEach(Array.prototype.slice.call(arguments, 1), function(source) {
        if (source) {
          forEach(source, function(value, key) {
            dest[key] = value;
          });
        }
      });
    }
    return dest;
  }

  function deepExtend(dest) {
    forEach(Array.prototype.slice.call(arguments, 1), function(source) {
      if (source) {
        forEach(source, function(value, key) {
          if (isArray(dest[key])) { // deep-extend each element of the array with the corresponding element from source
            var arr = dest[key];
            forEach(arr, function(elm, ix) {
              arr[ix] = deepExtend(elm, value[ix]);
            });
          }
          else if (isObject(dest[key])) { // deep-extend the object
            dest[key] = deepExtend(dest[key], value);
          }
          else {
            dest[key] = value;
          }
        });
      }
    });
    return dest;
  }

  // create a new function which is the specified function with the right-most arguments pre-filled
  function partialRight(fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
      return fn.apply(this, Array.prototype.slice.call(arguments, 0).concat(args));
    };
  }

  // return a function that will extend an object with the specified extensions
  // optionally applying them at points returned by extensionPointGetter
  function objectExtender(extensions, extensionPointGetter) {
    if (extensionPointGetter) {
      return function(obj) {
        if (obj) {
          forEach(extensionPointGetter(obj), function(extensionPoint) {
            extend(extensionPoint, extensions);
          });
        }
        return obj;
      };
    }
    else {
      return partialRight(extend, extensions);
    }
  }

  //noinspection JSUnusedLocalSymbols
  /**
   * Compose functions from right to left
   * @param {...Function} functions to compose; each argument may be a function or an array of functions
   * @returns {Function} composed function
   */
  function compose(functions) {
    /*jshint unused:false */
    var args = arguments;
    return function(obj) {
      for (var i = args.length-1; i >= 0; i--) {
        var arg = args[i];
        if (isArray(arg)) {
          for (var j = arg.length-1; j >= 0; j--) {
            obj = arg[j](obj);
          }
        }
        else {
          obj = arg(obj);
        }
      }
      return obj;
    };
  }

  // copy functions from source to dest, binding them to source
  function wrapFunctions(dest, source, fns) {
    forEach(fns, function(fn) {
      dest[fn] = function() {
        return source[fn].apply(source, arguments);
      };
    });
    return dest;
  }

  // extend the destPromise with functions from the sourcePromise
  function extendHttpPromise(destPromise, sourcePromise) {
    return wrapFunctions(destPromise, sourcePromise, ['getResponseHeader', 'getAllResponseHeaders', 'getStatusCode']);
  }

  // skip over optional arguments based upon predicate matching
  function getOptionalArgs(args, argPredicates) {
    var result = [];
    for (var i = 0, argPredicatesLen = argPredicates.length, j = 0, argsLen = args.length;
         i < argPredicatesLen && j < argsLen; i++) {
      if (argPredicates[i](args[j])) {
        result[i] = args[j++];
      }
    }
    return result;
  }

  // "empty" properties are undefined, null, or the empty string
  function removeEmptyProperties(obj) {
    forEach(obj, function(value, key) {
      if (value == null || value === '') {  // == null also catches undefined
        delete obj[key];
      }
    });
    return obj;
  }

  function getAbsoluteUrl(server, path) {
    if (!path.match(/^https?:\/\//)) {
      return server + (path.charAt(0) !== '/' ? '/' : '') + path;
    }
    else {
      return path;
    }
  }

  // Create a URL-encoded query string from an object
  function encodeQueryString(params) {
    var arr = [];
    forEach(params, function(value, key) {
      arr.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
    });
    return arr.join('&');
  }

  function appendQueryParameters(url, params) {
    var queryString = encodeQueryString(params);
    if (queryString.length === 0) {
      return url;
    }
    return url + (url.indexOf('?') >= 0 ? '&' : '?') + queryString;
  }

  function decodeQueryString(qs) {
    var obj = {}, segments = qs.substring(qs.indexOf('?')+1).split('&');
    forEach(segments, function(segment) {
      var kv = segment.split('=', 2);
      if (kv && kv[0]) {
        obj[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
      }
    });
    return obj;
  }

  function nextTick(cb) {
    setTimeout(function() {
      cb();
    },0);
  }

  // borrowed from AngularJS's implementation of $q
  // if passed a promise returns the promise; otherwise returns a pseudo-promise returning the value
  function refPromise(value) {
    if (value && isFunction(value.then)) {
      return value;
    }
    return {
      then: function(callback) {
        var d = deferredWrapper();
        nextTick(function() {
          d.resolve(callback(value));
        });
        return d.promise;
      }
    };
  }

  // borrowed from AngularJS's implementation of $q
  function promiseAll(promises) {
    var d = deferredWrapper(),
      counter = 0,
      results = isArray(promises) ? [] : {};

    forEach(promises, function(promise, key) {
      counter++;
      refPromise(promise).then(
        function(value) {
          if (results.hasOwnProperty(key)) {
            return;
          }
          results[key] = value;
          if (!(--counter)) {
            d.resolve(results);
          }
        },
        function() {
          if (results.hasOwnProperty(key)) {
            return;
          }
          d.reject.apply(d, arguments);
        });
    });

    if (counter === 0) {
      d.resolve(results);
    }

    return d.promise;
  }

  // cookie functions borrowed from http://www.quirksmode.org/js/cookies.html
  function createCookie(name,value,days) {
    var expires = '';
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*86400));
      expires = '; expires='+date.toUTCString();
    }
    document.cookie = name+'='+value+expires+'; path=/';
  }

  function readCookie(name) {
    var nameEQ = name + '=';
    var ca = document.cookie.split(';');
    for(var i=0;i < ca.length;i++) {
      var c = ca[i];
      while (c.charAt(0) ===' ') {
        c = c.substring(1,c.length);
      }
      if (c.indexOf(nameEQ) === 0) {
        return c.substring(nameEQ.length,c.length);
      }
    }
    return null;
  }

  function eraseCookie(name) {
    createCookie(name,'',-1);
  }

  // erase the access token
  function eraseAccessToken() {
    accessToken = null;
    if (saveAccessToken) {
      eraseCookie(accessTokenCookie);
    }
  }

  /**
   * Open a popup window for user to authenticate and authorize this app
   *
   * @private
   * @param {String} url window url
   * @param {Object} params query parameters to append to the window url
   * @return {window} reference to the popup window
   */
  function openPopup(url, params) {
    // figure out where the center is
    var
      screenX     = isUndefined(window.screenX) ? window.screenLeft : window.screenX,
      screenY     = isUndefined(window.screenY) ? window.screenTop : window.screenY,
      outerWidth  = isUndefined(window.outerWidth) ? document.documentElement.clientWidth : window.outerWidth,
      outerHeight = isUndefined(window.outerHeight) ? (document.documentElement.clientHeight - 22) : window.outerHeight,
      width       = params.width|| 780,
      height      = params.height || 500,
      left        = parseInt(screenX + ((outerWidth - width) / 2), 10),
      top         = parseInt(screenY + ((outerHeight - height) / 2.5), 10),
      features    = 'width=' + width + ',height=' + height + ',left=' + left + ',top=' + top;
    return window.open(appendQueryParameters(url, params),'',features);
  }

  /**
   * Polls the popup window location for the auth code
   *
   * @private
   * @param {window} popup window to poll
   * @return a promise of the auth code
   */
  function pollForAuthCode(popup) {
    var d = deferredWrapper();
    if (popup) {
      var i = setInterval(function() {
        try {
          if (popup.location.hostname === window.location.hostname) {
            var params = decodeQueryString(popup.location.href);
            clearInterval(i);
            popup.close();
            if (params['code']) {
              d.resolve(params['code']);
            }
            else {
              d.reject(params['error']);
            }
          }
        }
        catch(err) {}
      }, authCodePollDelay);
    }
    else {
      d.reject('Popup blocked');
    }
    return d.promise;
  }

  //==================================================================================================================
  // jQuery, Angular, and Node.js wrappers
  //==================================================================================================================

  function jqueryHttpWrapper(ajax) {
    return function(method, url, headers, data, opts) {
      // set up the options
      opts = extend({
        url: url,
        type: method,
        dataType: 'json',
        data: data
      }, opts);
      opts.headers = extend({}, headers, opts.headers);

      // make the call
      var jqXHR = ajax(opts);

      // process the response
      var d = deferredWrapper();
      var returnedPromise = d.promise;
      var statusCode = null;
      jqXHR.then(
        function(data, textStatus, jqXHR) {
          statusCode = jqXHR.status;
          d.resolve(data);
        },
        function(jqXHR, textStatus, errorThrown) {
          statusCode = jqXHR.status;
          d.reject(jqXHR, textStatus, errorThrown);
        });

      // add http-specific functions to the returned promise
      wrapFunctions(returnedPromise, jqXHR, ['getResponseHeader', 'getAllResponseHeaders']);
      returnedPromise.getStatusCode = function() {
        return statusCode;
      };
      return returnedPromise;
    };
  }

  function jqueryDeferredWrapper(deferred) {
    return function() {
      var d = deferred();
      return {
        promise: d.promise(),
        resolve: d.resolve,
        reject: d.reject
      };
    };
  }

//  function qDeferredWrapper(deferred) {
//    return function() {
//      var d = deferred();
//      return {
//        promise: d.promise,
//        resolve: d.resolve,
//        reject: d.reject
//      };
//    };
//  }

  //==================================================================================================================
  // Exported functions
  //==================================================================================================================

  window.FamilySearch = {
    // init
    init: init,
    // authentication
    getAuthCode: getAuthCode,
    getAccessToken: getAccessToken,
    hasAccessToken: hasAccessToken,
    invalidateAccessToken: invalidateAccessToken,
    // user
    getCurrentUser: getCurrentUser,
    getCurrentUserPerson: getCurrentUserPerson,
    // person
    getPerson: getPerson,
    getMultiPerson: getMultiPerson,
    getPersonWithRelationships: getPersonWithRelationships,
    // pedigree
    getAncestry: getAncestry,
    getDescendancy: getDescendancy,
    // plumbing
    get: get,
    post: post,
    put: put,
    del: del,
    http: http,
    getTotalProcessingTime: getTotalProcessingTime,
    setTotalProcessingTime: setTotalProcessingTime
  };
})();
